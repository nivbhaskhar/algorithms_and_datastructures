# -*- coding: utf-8 -*-
"""Longest_path_in_DAG_problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1tV1z72xmrXRRBUb0ziothO5yfkkgyNAT

# Leetcode Problem : Jump Game V

[https://leetcode.com/contest/weekly-contest-174/problems/jump-game-v/](https://leetcode.com/contest/weekly-contest-174/problems/jump-game-v/)
"""

import pprint
from typing import List
from collections import defaultdict, deque
class Solution:
    def maxJumps(self, arr: List[int], d: int) -> int:
        #create DAG
        
        n = len(arr)
        vertices = list(range(n))
        adjacency_dict = defaultdict(list) 
        predec_dict = defaultdict(list)
        indegree_list = [0]*n
        
        #update adjacency dict and initialize indegrees simultaneously
        for vertex in vertices:
            leftend = max(0, vertex - d)
            rightend = min(n-1, vertex + d)
            for node in range(vertex-1,leftend-1, -1):
                if arr[node] < arr[vertex]:
                    adjacency_dict[vertex].append(node)
                    predec_dict[node].append(vertex)
                    indegree_list[node] += 1
                else:
                    break
            for node in range(vertex+1, rightend+1):
                if arr[node] < arr[vertex]:
                    adjacency_dict[vertex].append(node)
                    predec_dict[node].append(vertex)
                    indegree_list[node] += 1
                else:
                    break
                    
        #pprint.pprint(adjacency_dict)
        #pprint.pprint(predec_dict)
        #pprint.pprint(indegree_list)
            
            
        #create queue of indegree 0 vertices
        indegree_0_queue = deque([i for i in range(n) if indegree_list[i]==0])
        no_of_degree_0_initially = len(indegree_0_queue)
        #pprint.pprint(indegree_0_queue)
        
        topologically_sorted_vertices = []
        #topological sort
        while indegree_0_queue:
            processing_vertex = indegree_0_queue.popleft()
            topologically_sorted_vertices.append(processing_vertex)
            for neighbour in adjacency_dict[processing_vertex]:
                indegree_list[neighbour] -= 1
                if indegree_list[neighbour] == 0:
                    indegree_0_queue.append(neighbour)
                    
        #pprint.pprint(topologically_sorted_vertices)
        
        answer = 0
        pathlength_to_ = {}
        
       
        for j in range(n):
            v = topologically_sorted_vertices[j]
            maxlength = 0
            for predec in predec_dict[v]:
                    maxlength = max(maxlength, pathlength_to_[predec]) 
                    
            if predec_dict[v]:   
                pathlength_to_[v] = maxlength + 1
            else:
                pathlength_to_[v] = maxlength
                
                
        answer = max(answer, max(pathlength_to_.values()))
            
        return answer+1

sol = Solution()

sol.maxJumps([6,4,14,6,8,13,9,7,10,6,12],2)

