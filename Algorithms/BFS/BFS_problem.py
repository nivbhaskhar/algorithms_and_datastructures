# -*- coding: utf-8 -*-
"""BFS_problem.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1n5G_R6yiETH4qnpuy9fkvgQAU4Z5MniI

# BFS problem

Given an N x M chessboard,

s = (s_0, s_1), the start position of a knight


t = (t_0, t_1), the target position of a knight

Output a path connecting s and t by knight moves. If a knight cannot move from s to t, output [(-1,-1)]
"""

import pprint
from typing import List, Tuple
from collections import defaultdict, deque
class Solution:
    def KnightPath(self, N: int, M: int , s: Tuple[int], t: Tuple[int]) -> List[Tuple[int]]:
        #create graph
        
        vertices = [ (i, j) for i in range(N) for j in range(M) ]
        adjacency_dict = defaultdict(list) 
        parent_dict = {}
        visited = {}
        queue_to_explore = deque([])


        
        #update adjacency dict and initialize visited to False
        for (i,j) in vertices:
          visited[(i,j)]= False
          neighbours = [(i-2,j-1), (i-2, j+1), (i-1,j-2), (i-1, j+2), (i+1,j-2), (i+1, j+2), (i+2,j-1), (i+2, j+1)]
          for (a,b) in neighbours:
            if (0<=a) and (a<N):
              if (0<=b) and (b<M):
                adjacency_dict[(i,j)].append((a,b))
        #pprint.pprint(adjacency_dict)


        visited[s] = True
        queue_to_explore.append(s)

        while queue_to_explore:
          v = queue_to_explore.popleft()
          for w in adjacency_dict[v]:
            if visited[w] == False:
              visited[w]= True
              parent_dict[w]=v
              queue_to_explore.append(w)


        if visited[t]:
          my_path = []
          v = t
          while v in parent_dict:
            my_path.append(v)
            v = parent_dict[v]
          my_path.append(s)
          return list(reversed(my_path))
            

        else:
          return [(-1,-1)]

sol = Solution()

sol.KnightPath(3,4,(0,0), (2,2))

sol.KnightPath(3,3,(0,1), (1,1))

